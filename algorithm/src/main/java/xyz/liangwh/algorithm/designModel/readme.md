
	* Singleton单例模式

		* 
保证一个类仅有一个实例，并且提供一个全局可访问的窗口。
		* 
关键点：私有构造器，统一由窗口获取
		* 
优点：重复利用对象，减少资源浪费（减少创建销毁）
		* 
缺点：不能继承，与单一职责冲突，一个类应该只关心自己内部逻辑，而不关心外部如何创建自己
	* 
Strategy策略模式

		* 
当一个类的行为或者算法需要在运行期更改，随意变化的时候，比如2个参数，我可以让他们相加，相减，相乘等，这些运算就是策略。
		* 
关键点：实现同一个接口，方法传接口，接口定义方法操作对象。
		* 
优点：灵活，算法自由切换，避免过多if else分支
		* 
缺点：策略类增多，所有策略类都需要暴露。
	* 
Factory工厂模式

		* 
定义一个创建对象的接口，让子类决定实例化哪一个工厂类。
		* 
根据不同条件，创建不同的产品。
		* 
优点：一个调用者想要创建一个对象的时候，只需要关系对象的名称，key。不需要关系如何创建
		* 
缺点：如果需要扩展增加产品，需要增加具体的产品类，以及对应的工厂类，还需要工厂方法。
	* 
AbstractFactory抽象工厂

		* 
提供一个创建一系列或者相关的对象的接口。
		* 
优点：当一系列对象被设计成一起工作的时候，抽象工厂可保证调用方通过工厂获取的一系列对象，是可控的。
		* 
缺点：扩展性，扩展难度较大
	* 
Facada 门面模式 Mediator调停者

		* 
slf4j / 消息中间件
		* 
解决问题：调用方完成一项工作需要去调用多个对象的方法，而且调用的对象可能会不统一。通过一个门面对象，统一接受调用方的调用，内部协调。
		* 
优点：减少调用方代码，并且底层实现可灵活变化。提高安全性。
		* 
不符合开闭原则，当门面内需要修改比较麻烦，继承重新都不适用。
	* 
Decorator装饰器模式

		* 
解决问题：不想修改对象，而给对象增加功能
		* 
优点：装饰类和目标类互不影响，独立发展。
		* 
缺点：多层装饰比较复杂
	* 
ChainOfResponsibility责任链模式

		* 
接受请求，当前处理者无法处理的情况，将任务传递给下一个处理者，直到全部都无法处理或者其中一个处理返回结果。（冒泡事件）
		* 
优点：降低代码耦合度，调用方并不关心责任链中有多少处理者
		* 
缺点：不能保证请求一定被处理，如果长度过长，增加返回时间，影响性能，影响体验。
	* 
Observer观察者模式

		* 
一个对象状态改变时，所有依赖的对象都做出相应动作。
		* 
优点：观察者被观察者是抽象耦合，要有一套触发机制。
		* 
如果观察者对象过多，将事件通知给所有观察者，需要耗费时间。如果双方存在循环观察，会影响性能。观察者只知道结果，而不知道原因。
	* 
Composite组合模式

		* 
通常用来表示树状结构的时候使用。
	* 
Flyweight享元模式

		* 
减少重复创建相同对象，重复使用对象。
		* 
关键点：map装这些共享对象。
		* 
spring
		* 
优点：减少多余的创建操作，使用效率更高
		* 
缺点：需要保证共享对象的修改，不会影响系统的运行。
	* 
Proxy静态代理，动态代理模式

		* 
静态代理

			* 
类似装饰器模式，提供一个代理类，代理某一个实例，增强方法。
			* 
实现InvocationHandler接口invoke方法
			* 
基于接口为我们动态创建代理对象（先创建代理类class，再生成实例）。
		* 
动态代理

			* 
区别于静态代理，他不仅能为单一对象提供增强，通过某些机制，接受被代理对象，以及要代理的方法。
			* 
JDK代理：通过反射调用目标对象指定的方法，在方法前后增强。
			* 
CGLib代理：通过字节码操作，生成目标类的子类代理类，通过继承实现代理。字节码操作，生成子类代码。
	* 
Iterator迭代器模式

		* 
提供窗口供外部遍历
		* 
关键：next hasnext
	* 
Visitor访问者模式

		* 
稳定的数据结构和易变的操作耦合的方式
		* 
关键：在基础数据的类中添加方法接受访问者，然后将自己提供给访问者，由访问者实现访问操作。
	* 
Bulider构建者模式

		* 
将一个复杂的对象（由多个对象组成）的构建方式，提供简单的构建方式。构建不同类型的对象，可能会有巨大的区别，但是构建的方法确实不变且简单
	* 
Adapter适配器模式

		* 
作为两个不兼容的接口直接的桥梁
		* 
关键：通过集成或者依赖已有对象，实现目标需要适配的接口
	* 
Bridge桥接模式
	* 
Command 命令模式
	* 
Prototype原型模式

		* 
通过java clone方法，利用一个原有的对象，当需要创建这种对象的时候，通过拷贝创建新的对象
		* 
优点：性能提高，免去其中引用属性的创建，没有构造函数的约束
		* 
缺点：克隆方法需要全盘考虑，浅拷贝深拷贝，是否有循环引用
	* 
Memento备忘录模式

		* 
在不破坏封装性前提下，获得一个对象的状态，并在这个对象之外保存这个状态。通过备忘录的方式，保存副本，让原对象可回滚。
		* 
关键：调用方不与备忘录类耦合，与备忘录管理类耦合
		* 
优点：可回滚
		* 
缺点：消耗资源
	* 
TemplateMethod 模板方法模式

		* 
抽象类公开定义一个方法的执行过程。子类只需要实现执行过程中的接口。
		* 
优点：规范子类实现，封装不变，拓展可变部分。行为父类可控。
	* 
state 状态模式

		* 
对象行为根据状态的改变而改变
	* 
Intepeter解释器模式

		* 
对指定语法进行解析
		* 
关键：构建语法树，定义终结符与非终结符

